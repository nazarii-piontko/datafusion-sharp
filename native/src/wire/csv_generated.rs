// automatically generated by the FlatBuffers compiler, do not modify
// @generated

extern crate alloc;

#[allow(unused_imports, dead_code)]
pub mod data_fusion_sharp {

extern crate alloc;

pub enum CsvReadOptionsOffset {}
#[derive(Copy, Clone, PartialEq)]

/// Options for reading CSV files.
pub struct CsvReadOptions<'a> {
  pub _tab: ::flatbuffers::Table<'a>,
}

impl<'a> ::flatbuffers::Follow<'a> for CsvReadOptions<'a> {
  type Inner = CsvReadOptions<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: unsafe { ::flatbuffers::Table::new(buf, loc) } }
  }
}

impl<'a> CsvReadOptions<'a> {
  pub const VT_HAS_HEADER: ::flatbuffers::VOffsetT = 4;
  pub const VT_DELIMITER: ::flatbuffers::VOffsetT = 6;
  pub const VT_QUOTE: ::flatbuffers::VOffsetT = 8;
  pub const VT_TERMINATOR: ::flatbuffers::VOffsetT = 10;
  pub const VT_ESCAPE: ::flatbuffers::VOffsetT = 12;
  pub const VT_COMMENT: ::flatbuffers::VOffsetT = 14;
  pub const VT_NEWLINES_IN_VALUES: ::flatbuffers::VOffsetT = 16;
  pub const VT_SCHEMA_SERIALIZED: ::flatbuffers::VOffsetT = 18;

  #[inline]
  pub unsafe fn init_from_table(table: ::flatbuffers::Table<'a>) -> Self {
    CsvReadOptions { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: ::flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut ::flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args CsvReadOptionsArgs<'args>
  ) -> ::flatbuffers::WIPOffset<CsvReadOptions<'bldr>> {
    let mut builder = CsvReadOptionsBuilder::new(_fbb);
    if let Some(x) = args.schema_serialized { builder.add_schema_serialized(x); }
    builder.add_newlines_in_values(args.newlines_in_values);
    if let Some(x) = args.comment { builder.add_comment(x); }
    if let Some(x) = args.escape { builder.add_escape(x); }
    if let Some(x) = args.terminator { builder.add_terminator(x); }
    if let Some(x) = args.quote { builder.add_quote(x); }
    if let Some(x) = args.delimiter { builder.add_delimiter(x); }
    builder.add_has_header(args.has_header);
    builder.finish()
  }


  /// Does the CSV file have a header?
  ///
  /// If schema inference is run on a file with no headers, default column names
  /// are created.
  #[inline]
  pub fn has_header(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(CsvReadOptions::VT_HAS_HEADER, Some(true)).unwrap()}
  }
  /// An optional column delimiter. Defaults to ','.
  #[inline]
  pub fn delimiter(&self) -> Option<u8> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(CsvReadOptions::VT_DELIMITER, None)}
  }
  /// An optional quote character. Defaults to `b'"'`.
  #[inline]
  pub fn quote(&self) -> Option<u8> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(CsvReadOptions::VT_QUOTE, None)}
  }
  /// An optional terminator character. Defaults to None (CRLF).
  #[inline]
  pub fn terminator(&self) -> Option<u8> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(CsvReadOptions::VT_TERMINATOR, None)}
  }
  /// An optional escape character. Defaults to None.
  #[inline]
  pub fn escape(&self) -> Option<u8> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(CsvReadOptions::VT_ESCAPE, None)}
  }
  /// If enabled, lines beginning with this byte are ignored.
  #[inline]
  pub fn comment(&self) -> Option<u8> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(CsvReadOptions::VT_COMMENT, None)}
  }
  /// Specifies whether newlines in (quoted) values are supported.
  ///
  /// Parsing newlines in quoted values may be affected by execution behaviour such as
  /// parallel file scanning. Setting this to `true` ensures that newlines in values are
  /// parsed successfully, which may reduce performance.
  ///
  /// The default behaviour depends on the `datafusion.catalog.newlines_in_values` setting.
  #[inline]
  pub fn newlines_in_values(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(CsvReadOptions::VT_NEWLINES_IN_VALUES, Some(false)).unwrap()}
  }
  /// An optional schema to use when reading the CSV file. If not provided, the schema will be inferred from the data.
  /// Arrow serialized schema bytes.
  #[inline]
  pub fn schema_serialized(&self) -> Option<::flatbuffers::Vector<'a, u8>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<::flatbuffers::ForwardsUOffset<::flatbuffers::Vector<'a, u8>>>(CsvReadOptions::VT_SCHEMA_SERIALIZED, None)}
  }
}

impl ::flatbuffers::Verifiable for CsvReadOptions<'_> {
  #[inline]
  fn run_verifier(
    v: &mut ::flatbuffers::Verifier, pos: usize
  ) -> Result<(), ::flatbuffers::InvalidFlatbuffer> {
    v.visit_table(pos)?
     .visit_field::<bool>("has_header", Self::VT_HAS_HEADER, false)?
     .visit_field::<u8>("delimiter", Self::VT_DELIMITER, false)?
     .visit_field::<u8>("quote", Self::VT_QUOTE, false)?
     .visit_field::<u8>("terminator", Self::VT_TERMINATOR, false)?
     .visit_field::<u8>("escape", Self::VT_ESCAPE, false)?
     .visit_field::<u8>("comment", Self::VT_COMMENT, false)?
     .visit_field::<bool>("newlines_in_values", Self::VT_NEWLINES_IN_VALUES, false)?
     .visit_field::<::flatbuffers::ForwardsUOffset<::flatbuffers::Vector<'_, u8>>>("schema_serialized", Self::VT_SCHEMA_SERIALIZED, false)?
     .finish();
    Ok(())
  }
}
pub struct CsvReadOptionsArgs<'a> {
    pub has_header: bool,
    pub delimiter: Option<u8>,
    pub quote: Option<u8>,
    pub terminator: Option<u8>,
    pub escape: Option<u8>,
    pub comment: Option<u8>,
    pub newlines_in_values: bool,
    pub schema_serialized: Option<::flatbuffers::WIPOffset<::flatbuffers::Vector<'a, u8>>>,
}
impl<'a> Default for CsvReadOptionsArgs<'a> {
  #[inline]
  fn default() -> Self {
    CsvReadOptionsArgs {
      has_header: true,
      delimiter: None,
      quote: None,
      terminator: None,
      escape: None,
      comment: None,
      newlines_in_values: false,
      schema_serialized: None,
    }
  }
}

pub struct CsvReadOptionsBuilder<'a: 'b, 'b, A: ::flatbuffers::Allocator + 'a> {
  fbb_: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>,
  start_: ::flatbuffers::WIPOffset<::flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: ::flatbuffers::Allocator + 'a> CsvReadOptionsBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_has_header(&mut self, has_header: bool) {
    self.fbb_.push_slot::<bool>(CsvReadOptions::VT_HAS_HEADER, has_header, true);
  }
  #[inline]
  pub fn add_delimiter(&mut self, delimiter: u8) {
    self.fbb_.push_slot_always::<u8>(CsvReadOptions::VT_DELIMITER, delimiter);
  }
  #[inline]
  pub fn add_quote(&mut self, quote: u8) {
    self.fbb_.push_slot_always::<u8>(CsvReadOptions::VT_QUOTE, quote);
  }
  #[inline]
  pub fn add_terminator(&mut self, terminator: u8) {
    self.fbb_.push_slot_always::<u8>(CsvReadOptions::VT_TERMINATOR, terminator);
  }
  #[inline]
  pub fn add_escape(&mut self, escape: u8) {
    self.fbb_.push_slot_always::<u8>(CsvReadOptions::VT_ESCAPE, escape);
  }
  #[inline]
  pub fn add_comment(&mut self, comment: u8) {
    self.fbb_.push_slot_always::<u8>(CsvReadOptions::VT_COMMENT, comment);
  }
  #[inline]
  pub fn add_newlines_in_values(&mut self, newlines_in_values: bool) {
    self.fbb_.push_slot::<bool>(CsvReadOptions::VT_NEWLINES_IN_VALUES, newlines_in_values, false);
  }
  #[inline]
  pub fn add_schema_serialized(&mut self, schema_serialized: ::flatbuffers::WIPOffset<::flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<::flatbuffers::WIPOffset<_>>(CsvReadOptions::VT_SCHEMA_SERIALIZED, schema_serialized);
  }
  #[inline]
  pub fn new(_fbb: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>) -> CsvReadOptionsBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    CsvReadOptionsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> ::flatbuffers::WIPOffset<CsvReadOptions<'a>> {
    let o = self.fbb_.end_table(self.start_);
    ::flatbuffers::WIPOffset::new(o.value())
  }
}

impl ::core::fmt::Debug for CsvReadOptions<'_> {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    let mut ds = f.debug_struct("CsvReadOptions");
      ds.field("has_header", &self.has_header());
      ds.field("delimiter", &self.delimiter());
      ds.field("quote", &self.quote());
      ds.field("terminator", &self.terminator());
      ds.field("escape", &self.escape());
      ds.field("comment", &self.comment());
      ds.field("newlines_in_values", &self.newlines_in_values());
      ds.field("schema_serialized", &self.schema_serialized());
      ds.finish()
  }
}
}  // pub mod DataFusionSharp

