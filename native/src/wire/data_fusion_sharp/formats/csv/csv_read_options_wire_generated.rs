// automatically generated by the FlatBuffers compiler, do not modify
// @generated
extern crate alloc;
use super::*;
pub enum CsvReadOptionsWireOffset {}
#[derive(Copy, Clone, PartialEq)]

/// Options for reading CSV files.
pub struct CsvReadOptionsWire<'a> {
  pub _tab: ::flatbuffers::Table<'a>,
}

impl<'a> ::flatbuffers::Follow<'a> for CsvReadOptionsWire<'a> {
  type Inner = CsvReadOptionsWire<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: unsafe { ::flatbuffers::Table::new(buf, loc) } }
  }
}

impl<'a> CsvReadOptionsWire<'a> {
  pub const VT_HAS_HEADER: ::flatbuffers::VOffsetT = 4;
  pub const VT_DELIMITER: ::flatbuffers::VOffsetT = 6;
  pub const VT_QUOTE: ::flatbuffers::VOffsetT = 8;
  pub const VT_TERMINATOR: ::flatbuffers::VOffsetT = 10;
  pub const VT_ESCAPE: ::flatbuffers::VOffsetT = 12;
  pub const VT_COMMENT: ::flatbuffers::VOffsetT = 14;
  pub const VT_NEWLINES_IN_VALUES: ::flatbuffers::VOffsetT = 16;
  pub const VT_SCHEMA: ::flatbuffers::VOffsetT = 18;
  pub const VT_SCHEMA_INFER_MAX_RECORDS: ::flatbuffers::VOffsetT = 20;
  pub const VT_FILE_EXTENSION: ::flatbuffers::VOffsetT = 22;
  pub const VT_FILE_COMPRESSION_TYPE: ::flatbuffers::VOffsetT = 24;
  pub const VT_NULL_REGEX: ::flatbuffers::VOffsetT = 26;
  pub const VT_TRUNCATED_ROWS: ::flatbuffers::VOffsetT = 28;

  #[inline]
  pub unsafe fn init_from_table(table: ::flatbuffers::Table<'a>) -> Self {
    CsvReadOptionsWire { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: ::flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut ::flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args CsvReadOptionsWireArgs<'args>
  ) -> ::flatbuffers::WIPOffset<CsvReadOptionsWire<'bldr>> {
    let mut builder = CsvReadOptionsWireBuilder::new(_fbb);
    if let Some(x) = args.schema_infer_max_records { builder.add_schema_infer_max_records(x); }
    if let Some(x) = args.null_regex { builder.add_null_regex(x); }
    if let Some(x) = args.file_extension { builder.add_file_extension(x); }
    if let Some(x) = args.schema { builder.add_schema(x); }
    builder.add_truncated_rows(args.truncated_rows);
    if let Some(x) = args.file_compression_type { builder.add_file_compression_type(x); }
    builder.add_newlines_in_values(args.newlines_in_values);
    if let Some(x) = args.comment { builder.add_comment(x); }
    if let Some(x) = args.escape { builder.add_escape(x); }
    if let Some(x) = args.terminator { builder.add_terminator(x); }
    if let Some(x) = args.quote { builder.add_quote(x); }
    if let Some(x) = args.delimiter { builder.add_delimiter(x); }
    builder.add_has_header(args.has_header);
    builder.finish()
  }


  /// Whether the CSV file has a header row.
  /// If schema inference is run on a file with no headers, default column names are created.
  #[inline]
  pub fn has_header(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(CsvReadOptionsWire::VT_HAS_HEADER, Some(true)).unwrap()}
  }
  /// An optional column delimiter character (ASCII). Defaults to ','.
  #[inline]
  pub fn delimiter(&self) -> Option<u8> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(CsvReadOptionsWire::VT_DELIMITER, None)}
  }
  /// An optional quote character (ASCII). Defaults to '"'`.
  #[inline]
  pub fn quote(&self) -> Option<u8> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(CsvReadOptionsWire::VT_QUOTE, None)}
  }
  /// An optional terminator character (ASCII). Defaults to CRLF.
  #[inline]
  pub fn terminator(&self) -> Option<u8> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(CsvReadOptionsWire::VT_TERMINATOR, None)}
  }
  /// An optional escape character (ASCII).
  #[inline]
  pub fn escape(&self) -> Option<u8> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(CsvReadOptionsWire::VT_ESCAPE, None)}
  }
  /// An optional comment character (ASCII). Lines starting with this character are ignored.
  #[inline]
  pub fn comment(&self) -> Option<u8> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(CsvReadOptionsWire::VT_COMMENT, None)}
  }
  /// Specifies whether newlines in (quoted) values are supported.
  #[inline]
  pub fn newlines_in_values(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(CsvReadOptionsWire::VT_NEWLINES_IN_VALUES, Some(false)).unwrap()}
  }
  /// An optional schema to use when reading the CSV file.
  /// If not provided, the schema will be inferred from the data.
  /// Arrow serialized schema bytes.
  #[inline]
  pub fn schema(&self) -> Option<::flatbuffers::Vector<'a, u8>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<::flatbuffers::ForwardsUOffset<::flatbuffers::Vector<'a, u8>>>(CsvReadOptionsWire::VT_SCHEMA, None)}
  }
  /// Max number of rows to read from CSV files for schema inference if needed.
  #[inline]
  pub fn schema_infer_max_records(&self) -> Option<u64> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(CsvReadOptionsWire::VT_SCHEMA_INFER_MAX_RECORDS, None)}
  }
  /// File extension; only files with this extension are selected for data input.
  #[inline]
  pub fn file_extension(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<::flatbuffers::ForwardsUOffset<&str>>(CsvReadOptionsWire::VT_FILE_EXTENSION, None)}
  }
  /// File compression type.
  #[inline]
  pub fn file_compression_type(&self) -> Option<super::FileCompressionType> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<super::FileCompressionType>(CsvReadOptionsWire::VT_FILE_COMPRESSION_TYPE, None)}
  }
  /// Optional regex to match null values.
  #[inline]
  pub fn null_regex(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<::flatbuffers::ForwardsUOffset<&str>>(CsvReadOptionsWire::VT_NULL_REGEX, None)}
  }
  /// Whether to allow truncated rows when parsing.
  #[inline]
  pub fn truncated_rows(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(CsvReadOptionsWire::VT_TRUNCATED_ROWS, Some(false)).unwrap()}
  }
}

impl ::flatbuffers::Verifiable for CsvReadOptionsWire<'_> {
  #[inline]
  fn run_verifier(
    v: &mut ::flatbuffers::Verifier, pos: usize
  ) -> Result<(), ::flatbuffers::InvalidFlatbuffer> {
    v.visit_table(pos)?
     .visit_field::<bool>("has_header", Self::VT_HAS_HEADER, false)?
     .visit_field::<u8>("delimiter", Self::VT_DELIMITER, false)?
     .visit_field::<u8>("quote", Self::VT_QUOTE, false)?
     .visit_field::<u8>("terminator", Self::VT_TERMINATOR, false)?
     .visit_field::<u8>("escape", Self::VT_ESCAPE, false)?
     .visit_field::<u8>("comment", Self::VT_COMMENT, false)?
     .visit_field::<bool>("newlines_in_values", Self::VT_NEWLINES_IN_VALUES, false)?
     .visit_field::<::flatbuffers::ForwardsUOffset<::flatbuffers::Vector<'_, u8>>>("schema", Self::VT_SCHEMA, false)?
     .visit_field::<u64>("schema_infer_max_records", Self::VT_SCHEMA_INFER_MAX_RECORDS, false)?
     .visit_field::<::flatbuffers::ForwardsUOffset<&str>>("file_extension", Self::VT_FILE_EXTENSION, false)?
     .visit_field::<super::FileCompressionType>("file_compression_type", Self::VT_FILE_COMPRESSION_TYPE, false)?
     .visit_field::<::flatbuffers::ForwardsUOffset<&str>>("null_regex", Self::VT_NULL_REGEX, false)?
     .visit_field::<bool>("truncated_rows", Self::VT_TRUNCATED_ROWS, false)?
     .finish();
    Ok(())
  }
}
pub struct CsvReadOptionsWireArgs<'a> {
    pub has_header: bool,
    pub delimiter: Option<u8>,
    pub quote: Option<u8>,
    pub terminator: Option<u8>,
    pub escape: Option<u8>,
    pub comment: Option<u8>,
    pub newlines_in_values: bool,
    pub schema: Option<::flatbuffers::WIPOffset<::flatbuffers::Vector<'a, u8>>>,
    pub schema_infer_max_records: Option<u64>,
    pub file_extension: Option<::flatbuffers::WIPOffset<&'a str>>,
    pub file_compression_type: Option<super::FileCompressionType>,
    pub null_regex: Option<::flatbuffers::WIPOffset<&'a str>>,
    pub truncated_rows: bool,
}
impl<'a> Default for CsvReadOptionsWireArgs<'a> {
  #[inline]
  fn default() -> Self {
    CsvReadOptionsWireArgs {
      has_header: true,
      delimiter: None,
      quote: None,
      terminator: None,
      escape: None,
      comment: None,
      newlines_in_values: false,
      schema: None,
      schema_infer_max_records: None,
      file_extension: None,
      file_compression_type: None,
      null_regex: None,
      truncated_rows: false,
    }
  }
}

pub struct CsvReadOptionsWireBuilder<'a: 'b, 'b, A: ::flatbuffers::Allocator + 'a> {
  fbb_: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>,
  start_: ::flatbuffers::WIPOffset<::flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: ::flatbuffers::Allocator + 'a> CsvReadOptionsWireBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_has_header(&mut self, has_header: bool) {
    self.fbb_.push_slot::<bool>(CsvReadOptionsWire::VT_HAS_HEADER, has_header, true);
  }
  #[inline]
  pub fn add_delimiter(&mut self, delimiter: u8) {
    self.fbb_.push_slot_always::<u8>(CsvReadOptionsWire::VT_DELIMITER, delimiter);
  }
  #[inline]
  pub fn add_quote(&mut self, quote: u8) {
    self.fbb_.push_slot_always::<u8>(CsvReadOptionsWire::VT_QUOTE, quote);
  }
  #[inline]
  pub fn add_terminator(&mut self, terminator: u8) {
    self.fbb_.push_slot_always::<u8>(CsvReadOptionsWire::VT_TERMINATOR, terminator);
  }
  #[inline]
  pub fn add_escape(&mut self, escape: u8) {
    self.fbb_.push_slot_always::<u8>(CsvReadOptionsWire::VT_ESCAPE, escape);
  }
  #[inline]
  pub fn add_comment(&mut self, comment: u8) {
    self.fbb_.push_slot_always::<u8>(CsvReadOptionsWire::VT_COMMENT, comment);
  }
  #[inline]
  pub fn add_newlines_in_values(&mut self, newlines_in_values: bool) {
    self.fbb_.push_slot::<bool>(CsvReadOptionsWire::VT_NEWLINES_IN_VALUES, newlines_in_values, false);
  }
  #[inline]
  pub fn add_schema(&mut self, schema: ::flatbuffers::WIPOffset<::flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<::flatbuffers::WIPOffset<_>>(CsvReadOptionsWire::VT_SCHEMA, schema);
  }
  #[inline]
  pub fn add_schema_infer_max_records(&mut self, schema_infer_max_records: u64) {
    self.fbb_.push_slot_always::<u64>(CsvReadOptionsWire::VT_SCHEMA_INFER_MAX_RECORDS, schema_infer_max_records);
  }
  #[inline]
  pub fn add_file_extension(&mut self, file_extension: ::flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<::flatbuffers::WIPOffset<_>>(CsvReadOptionsWire::VT_FILE_EXTENSION, file_extension);
  }
  #[inline]
  pub fn add_file_compression_type(&mut self, file_compression_type: super::FileCompressionType) {
    self.fbb_.push_slot_always::<super::FileCompressionType>(CsvReadOptionsWire::VT_FILE_COMPRESSION_TYPE, file_compression_type);
  }
  #[inline]
  pub fn add_null_regex(&mut self, null_regex: ::flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<::flatbuffers::WIPOffset<_>>(CsvReadOptionsWire::VT_NULL_REGEX, null_regex);
  }
  #[inline]
  pub fn add_truncated_rows(&mut self, truncated_rows: bool) {
    self.fbb_.push_slot::<bool>(CsvReadOptionsWire::VT_TRUNCATED_ROWS, truncated_rows, false);
  }
  #[inline]
  pub fn new(_fbb: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>) -> CsvReadOptionsWireBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    CsvReadOptionsWireBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> ::flatbuffers::WIPOffset<CsvReadOptionsWire<'a>> {
    let o = self.fbb_.end_table(self.start_);
    ::flatbuffers::WIPOffset::new(o.value())
  }
}

impl ::core::fmt::Debug for CsvReadOptionsWire<'_> {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    let mut ds = f.debug_struct("CsvReadOptionsWire");
      ds.field("has_header", &self.has_header());
      ds.field("delimiter", &self.delimiter());
      ds.field("quote", &self.quote());
      ds.field("terminator", &self.terminator());
      ds.field("escape", &self.escape());
      ds.field("comment", &self.comment());
      ds.field("newlines_in_values", &self.newlines_in_values());
      ds.field("schema", &self.schema());
      ds.field("schema_infer_max_records", &self.schema_infer_max_records());
      ds.field("file_extension", &self.file_extension());
      ds.field("file_compression_type", &self.file_compression_type());
      ds.field("null_regex", &self.null_regex());
      ds.field("truncated_rows", &self.truncated_rows());
      ds.finish()
  }
}
