using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace DataFusionSharp.SourceGenerators;

[Generator]
public sealed class NativeCallbackGenerator : IIncrementalGenerator
{
    private const string AttributeFullName = "DataFusionSharp.Interop.NativeCallbackAttribute";

    private const string AttributeSource = """
        // <auto-generated/>
        namespace DataFusionSharp.Interop
        {
            [global::System.AttributeUsage(global::System.AttributeTargets.Method,
                AllowMultiple = false, Inherited = false)]
            internal sealed class NativeCallbackAttribute : global::System.Attribute { }
        }
        """;

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // 1. Emit the attribute
        context.RegisterPostInitializationOutput(ctx =>
            ctx.AddSource("NativeCallbackAttribute.g.cs", AttributeSource));

        // 2. Find annotated methods
        var methodData = context.SyntaxProvider
            .ForAttributeWithMetadataName(
                AttributeFullName,
                predicate: static (node, _) =>
                    node is MethodDeclarationSyntax method &&
                    method.Modifiers.Any(SyntaxKind.StaticKeyword),
                transform: static (ctx, _) => ExtractMethodData(ctx))
            .Where(static m => m is not null)
            .Select(static (m, _) => m!);

        // 3. Collect all, group by type, emit one file per type
        var collected = methodData.Collect();
        context.RegisterSourceOutput(collected, EmitSources);
    }

    private static void EmitSources(SourceProductionContext ctx, ImmutableArray<MethodData> methods)
    {
        var grouped = methods
            .GroupBy(m => m.TypeFullName, StringComparer.Ordinal);

        foreach (var group in grouped)
        {
            var items = group.ToImmutableArray();
            var first = items[0];
            var fileName = first.TypeName + "_NativeCallbacks.g.cs";
            var source = GenerateSource(first, items);
            ctx.AddSource(fileName, source);
        }
    }

    private static MethodData? ExtractMethodData(GeneratorAttributeSyntaxContext ctx)
    {
        if (ctx.TargetSymbol is not IMethodSymbol method)
            return null;

        var containingType = method.ContainingType;
        if (containingType is null)
            return null;

        var ns = containingType.ContainingNamespace.IsGlobalNamespace
            ? string.Empty
            : containingType.ContainingNamespace.ToDisplayString();

        var typeModifiers = GetTypeModifiers(containingType);
        var typeName = containingType.Name;
        var typeFullName = string.IsNullOrEmpty(ns) ? typeName : ns + "." + typeName;

        var methodAccessibility = method.DeclaredAccessibility switch
        {
            Accessibility.Public => "public",
            Accessibility.Internal => "internal",
            Accessibility.Protected => "protected",
            Accessibility.ProtectedOrInternal => "protected internal",
            _ => "private"
        };

        return new MethodData(ns, typeName, typeFullName, typeModifiers, method.Name, methodAccessibility);
    }

    private static string GetTypeModifiers(INamedTypeSymbol type)
    {
        var parts = new List<string>();

        parts.Add(type.DeclaredAccessibility switch
        {
            Accessibility.Public => "public",
            Accessibility.Internal => "internal",
            Accessibility.Protected => "protected",
            Accessibility.ProtectedOrInternal => "protected internal",
            _ => "private"
        });

        if (type.IsStatic)
            parts.Add("static");
        else if (type.IsSealed && type.TypeKind == TypeKind.Class)
            parts.Add("sealed");
        else if (type.IsAbstract && type.TypeKind == TypeKind.Class)
            parts.Add("abstract");

        parts.Add("partial");

        parts.Add(type.TypeKind switch
        {
            TypeKind.Interface => "interface",
            TypeKind.Struct => "struct",
            _ => "class"
        });

        return string.Join(" ", parts);
    }

    private static string GenerateSource(MethodData first, ImmutableArray<MethodData> methods)
    {
        var sb = new StringBuilder();
        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine("#nullable enable");

        var hasNamespace = !string.IsNullOrEmpty(first.Namespace);
        if (hasNamespace)
        {
            sb.AppendLine("namespace " + first.Namespace);
            sb.AppendLine("{");
        }

        var typeIndent = hasNamespace ? "    " : "";
        var memberIndent = hasNamespace ? "        " : "    ";

        sb.AppendLine(typeIndent + first.TypeModifiers + " " + first.TypeName);
        sb.AppendLine(typeIndent + "{");

        for (var i = 0; i < methods.Length; i++)
        {
            if (i > 0)
                sb.AppendLine();

            var m = methods[i];
            sb.AppendLine(
                memberIndent +
                "private static readonly global::DataFusionSharp.Interop.NativeMethods.Callback " +
                m.MethodName + "Delegate = " + m.MethodName + ";");
            sb.AppendLine(
                memberIndent +
                m.MethodAccessibility + " static readonly global::System.IntPtr " +
                m.MethodName + "Handler = " +
                "global::System.Runtime.InteropServices.Marshal.GetFunctionPointerForDelegate(" +
                m.MethodName + "Delegate);");
        }

        sb.AppendLine(typeIndent + "}");

        if (hasNamespace)
            sb.AppendLine("}");

        return sb.ToString();
    }

    private sealed class MethodData
    {
        public MethodData(
            string @namespace,
            string typeName,
            string typeFullName,
            string typeModifiers,
            string methodName,
            string methodAccessibility)
        {
            Namespace = @namespace;
            TypeName = typeName;
            TypeFullName = typeFullName;
            TypeModifiers = typeModifiers;
            MethodName = methodName;
            MethodAccessibility = methodAccessibility;
        }

        public string Namespace { get; }
        public string TypeName { get; }
        public string TypeFullName { get; }
        public string TypeModifiers { get; }
        public string MethodName { get; }
        public string MethodAccessibility { get; }
    }
}
